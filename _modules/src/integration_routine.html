<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>src.integration_routine &mdash; Trapped Ion Sim  documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Trapped Ion Sim  documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Trapped Ion Sim  documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for src.integration_routine</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/python2.7</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># Author:  Mario S. KÃ¶nz &lt;mskoenz@gmx.net&gt;</span>
<span class="c"># Date:    21.06.2014 23:49:11 CEST</span>
<span class="c"># File:    all_to_all.py</span>

<span class="kn">from</span> <span class="nn">.src_import</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.atom_class</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.vibron_class</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.laser_class</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.helper</span> <span class="kn">import</span> <span class="n">hold_args</span><span class="p">,</span> <span class="n">tag_class</span><span class="p">,</span> <span class="n">tensor</span>

<span class="c">#=================== global variables ===================</span>
<span class="n">default_cutoff</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">the default cutoff frequency used by :func:`create_hamiltonian`</span>
<span class="sd">&quot;&quot;&quot;</span>

<div class="viewcode-block" id="create_phi"><a class="viewcode-back" href="../../src.html#src.integration_routine.create_phi">[docs]</a><span class="k">def</span> <span class="nf">create_phi</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    creates the initial global state phi by adding (tensor) the atom and vibron states</span>
<span class="sd">    </span>
<span class="sd">    :returns: a `qutip.Qobj` that contains the density matrix of the global state</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vibron_holder_</span><span class="o">.</span><span class="n">current_dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">atom_holder_</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">atom_holder_</span><span class="o">.</span><span class="n">state</span><span class="p">(),</span> <span class="n">vibron_holder_</span><span class="o">.</span><span class="n">state</span><span class="p">())</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="res_collector"><a class="viewcode-back" href="../../src.html#src.integration_routine.res_collector">[docs]</a><span class="k">class</span> <span class="nc">res_collector</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    the mesovle as well as other solve methods of qutip take an list of Qobj matrices as observables or a callback function. this class contains the callback functions as well as the datastructure that collects the data. it is done in the same fashion as in mesolve.py of the qutip framework. the callback is only used if there are measurements that aren&#39;t represented by the form expect(operator, state).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="res_collector.__init__"><a class="viewcode-back" href="../../src.html#src.integration_routine.res_collector.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        the constructor initializes the class with one timestep and no functions</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span><span class="p">([],</span> <span class="mi">1</span><span class="p">)</span></div>
<div class="viewcode-block" id="res_collector.init"><a class="viewcode-back" href="../../src.html#src.integration_routine.res_collector.init">[docs]</a>    <span class="k">def</span> <span class="nf">init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fct</span><span class="p">,</span> <span class="n">n_tsteps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        init is used by :func:`create_obs` if there are non expectation value (see class description) measurement functions.</span>
<span class="sd">        </span>
<span class="sd">        :param fct: is a list of python functions with the signature: f(time, state) and return a float</span>
<span class="sd">        :param n_tsteps: has to be the same as cf[&quot;measure&quot;] (represents how many measurements are taken during the integration)</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_tsteps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fct</span> <span class="o">=</span> <span class="n">fct</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fct</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_tsteps</span><span class="p">))</span></div>
<div class="viewcode-block" id="res_collector.measure"><a class="viewcode-back" href="../../src.html#src.integration_routine.res_collector.measure">[docs]</a>    <span class="k">def</span> <span class="nf">measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this function will call all functions in `fct` and store the return value.</span>
<span class="sd">        </span>
<span class="sd">        :param t: the time at which the measurement is taken</span>
<span class="sd">        :param state: the density matrix representing the state at time t</span>
<span class="sd">        </span>
<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">i_f</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fct</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">i_f</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">t_idx</span> <span class="o">+=</span> <span class="mi">1</span>
</div></div>
<span class="n">res</span> <span class="o">=</span> <span class="n">res_collector</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">the only instance that should be used in the framework.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="callback_fct"><a class="viewcode-back" href="../../src.html#src.integration_routine.callback_fct">[docs]</a><span class="k">def</span> <span class="nf">callback_fct</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    this is the callback function given to the solver routines. it calls `res.measure`</span>
<span class="sd">    </span>
<span class="sd">    :param t: the time at which the measurement is taken</span>
<span class="sd">    :param state: the density matrix representing the state at time t</span>
<span class="sd">    </span>
<span class="sd">    :returns: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">res</span>
    <span class="n">res</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">Qobj</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
    </div>
<div class="viewcode-block" id="create_obs"><a class="viewcode-back" href="../../src.html#src.integration_routine.create_obs">[docs]</a><span class="k">def</span> <span class="nf">create_obs</span><span class="p">(</span><span class="n">cf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    creates the observables specified in cf[&quot;plot&quot;]. one can use a simplified language to formulate the observables in an more convenient way. if a certain form is not supported it can be expanded to do so. For now valid discription code is:</span>
<span class="sd">    </span>
<span class="sd">    - &quot;fidelity(atom1(...), state); label&quot; important is the &quot;; &quot; before writing the label (how the plot line is called)</span>
<span class="sd">    - &quot;atom1(...); label&quot; this will produce an operator. the expectation value will be measured </span>
<span class="sd">    - &quot;tensor(atom1(...), atom2(...)); label&quot;</span>
<span class="sd">    - &quot;laser1(.3); label&quot; the argument in laser1 just determines the y-location in the plot. it has no computational meaning</span>
<span class="sd">    </span>
<span class="sd">    :param cf: canonical form of the integration problem</span>
<span class="sd">    :return: obs, laser_obs, callback</span>
<span class="sd">    - `obs`: is eighter a list of operators or a python function (callback, see QuTip mesolve)</span>
<span class="sd">    - `laser_obs`: a list of functions that are calculated after the integration, since the lasers are independent of the state</span>
<span class="sd">    - `callback`: a boolean value that states if the callback or the obs_list is returned. this is done for speedup, since the callback is slower and only used if needed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">res</span>
    <span class="n">flatten</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
    
    <span class="n">tag_class</span><span class="o">.</span><span class="n">all_sys</span> <span class="o">=</span> <span class="n">atom_holder_</span><span class="o">.</span><span class="n">atom_list</span> <span class="o">+</span> <span class="n">vibron_holder_</span><span class="o">.</span><span class="n">vibron_list</span>

    <span class="n">pi</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">cf</span><span class="p">[</span><span class="s">&quot;plot&quot;</span><span class="p">])</span>
    <span class="c">#------------------- collect all names ------------------- </span>
    <span class="n">a_nm</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;atom&quot;</span><span class="p">]]</span>
    <span class="n">v_nm</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;vibron&quot;</span><span class="p">]]</span>
    <span class="n">l_nm</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;laser&quot;</span><span class="p">]]</span>
    
    <span class="n">pi</span> <span class="o">=</span> <span class="p">[</span><span class="n">hold_args</span><span class="p">(</span><span class="n">a_nm</span> <span class="o">+</span> <span class="n">v_nm</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pi</span><span class="p">]</span>
    
    <span class="n">all_nm</span> <span class="o">=</span> <span class="n">a_nm</span> <span class="o">+</span> <span class="n">v_nm</span> <span class="o">+</span> <span class="n">l_nm</span>
    
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i_a</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">a_nm</span><span class="p">):</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&quot; =  tag_class(&#39;&quot;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&quot;&#39;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_a</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">i_v</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">v_nm</span><span class="p">):</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="s">&quot; =  tag_class(&#39;&quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s">&quot;&#39;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_v</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_nm</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">()</span>
    
    <span class="k">class</span> <span class="nc">laser_helper</span><span class="p">():</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magn</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">magn</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">closure</span>
    
    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">i_l</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">l_nm</span><span class="p">):</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="s">&quot; = laser_helper(&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cf</span><span class="p">[</span><span class="s">&quot;laser&quot;</span><span class="p">][</span><span class="n">i_l</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">fidelity</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sys</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">fidelity</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">ptrace</span><span class="p">(</span><span class="n">sys</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">closure</span>
    
    <span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="n">expect</span>
    
    <span class="n">callback</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">fct</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">op_map</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">laser_fct</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">i_p</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">pi</span><span class="p">):</span>
        <span class="n">is_laser</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_nm</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">is_laser</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        
        <span class="k">if</span> <span class="n">is_laser</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&quot;f = &quot;</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">()</span>
            <span class="n">laser_fct</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">i_p</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;fidelity&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&quot;f = &quot;</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">()</span>
            <span class="n">fct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="n">op_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">expect</span><span class="p">(</span><span class="n">op_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">f</span>
            
            <span class="n">fct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closure</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">op_map</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">op_map</span><span class="p">,</span> <span class="n">laser_fct</span><span class="p">,</span> <span class="n">callback</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">fct</span><span class="p">,</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;measure&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">callback_fct</span><span class="p">,</span> <span class="n">laser_fct</span><span class="p">,</span> <span class="n">callback</span>
</div>
<div class="viewcode-block" id="create_collpase_ops"><a class="viewcode-back" href="../../src.html#src.integration_routine.create_collpase_ops">[docs]</a><span class="k">def</span> <span class="nf">create_collpase_ops</span><span class="p">(</span><span class="n">cf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    this function creates the collpase operators based on the string inputs on cf[&quot;collapse&quot;]. examples:</span>
<span class="sd">    </span>
<span class="sd">    - &quot;atom1(fock_dm(N, 2))&quot; inside the atom1 function any valid expression that results in a Qobj of the right dimension can be given</span>
<span class="sd">    - &quot;0.5*atom1(...)&quot; doesn&#39;t work, since atom1(...) is not an operator from the programms perspective</span>
<span class="sd">    - &quot;0.5*tensor(atom1(...))&quot; works since tensor transforms the atom1 obj into a Qobj, where 0.5* is valid code</span>
<span class="sd">    - &quot;tensor(atom1(...), atom5(...))&quot; the tensor automatically produces the right global state</span>
<span class="sd">    - timedependent collapse ops not possible yet, but the function can be expanded</span>
<span class="sd">    </span>
<span class="sd">    :param cf: canonical form of the integration problem</span>
<span class="sd">    :return: a list of operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;collapse&quot;</span><span class="p">]</span>
    
    <span class="n">a_nm</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;atom&quot;</span><span class="p">]]</span>
    <span class="n">v_nm</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;vibron&quot;</span><span class="p">]]</span>
    
    <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="n">hold_args</span><span class="p">(</span><span class="n">a_nm</span> <span class="o">+</span> <span class="n">v_nm</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i_a</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">a_nm</span><span class="p">):</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">&quot; =  tag_class(&#39;&quot;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="s">&quot;&#39;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_a</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">i_v</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">v_nm</span><span class="p">):</span>
        <span class="k">exec</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="s">&quot; =  tag_class(&#39;&quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s">&quot;&#39;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_v</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_nm</span><span class="p">))</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">()</span>
    
    <span class="n">col_ops</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="n">col_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">col_ops</span>
    </div>
<div class="viewcode-block" id="create_hamiltonian"><a class="viewcode-back" href="../../src.html#src.integration_routine.create_hamiltonian">[docs]</a><span class="k">def</span> <span class="nf">create_hamiltonian</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">vibrons</span><span class="p">,</span> <span class="n">lasers</span><span class="p">,</span> <span class="n">_rabi</span><span class="p">,</span> <span class="n">_eta</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param atoms: a list of :class:`atom`</span>
<span class="sd">    :param vibrons: a list of :class:`vibron`</span>
<span class="sd">    :param lasers: a list of :class:`laser`</span>
<span class="sd">    :param _rabi: a list containing the rabi-frequency with the following dimensions: list[N_lasers][N_atoms][N_transitions_per_atom]. since the amount of transitions can be different for each atom, the last dimension will depend on the atom and is not the same for all atoms.</span>
<span class="sd">    :param _eta: a list containing the lamb-dicke parameter with the following dimensions: list[N_atoms][N_vibrons]</span>
<span class="sd">    :param **kwargs: key word arguments for additional optional parameters like cutoff. if no cutoff is given, it will be set to `default_cutoff`. hbar is an mandatory kwarg and is the value for the reduced planck constant.</span>
<span class="sd">    :returns: a list with [operator, pattern, time dependency] entries for each component in the hamiltonian as well as a dictionary that holds all variables that can be found in the time dependency cython strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">vibron_holder_</span>
    
    <span class="k">if</span> <span class="s">&quot;cutoff&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;cutoff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_cutoff</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;cutoff&quot;</span><span class="p">]</span>
    
    <span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">col_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">col_args</span><span class="p">[</span><span class="s">&quot;hb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;hbar&quot;</span><span class="p">]</span>
    
    <span class="n">rwa_takes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">i_l</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">lasers</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">i_a</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">i_t</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">trans</span><span class="p">):</span>
                <span class="n">trans_label</span> <span class="o">=</span> <span class="s">&quot;w0_A&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_a</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;T&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_t</span><span class="p">)</span>
                <span class="n">rabi_label</span> <span class="o">=</span> <span class="s">&quot;Ohm_L&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_l</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;A&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_a</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;T&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_t</span><span class="p">)</span>
                <span class="n">laser_label</span> <span class="o">=</span> <span class="s">&quot;wL_L&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_l</span><span class="p">)</span>
                <span class="n">phase_label</span> <span class="o">=</span> <span class="s">&quot;fL_L&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_l</span><span class="p">)</span>
                <span class="c">#------------------- set up the operators ------------------- </span>
                <span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">col_args</span><span class="p">[</span><span class="n">rabi_label</span><span class="p">]</span>  <span class="o">=</span> <span class="n">_rabi</span><span class="p">[</span><span class="n">i_l</span><span class="p">][</span><span class="n">i_a</span><span class="p">][</span><span class="n">i_t</span><span class="p">]</span>
                <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">freq</span>
                <span class="n">col_args</span><span class="p">[</span><span class="n">phase_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">phase</span>
                
                <span class="n">d_internal</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_internal</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">vibron_holder_</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
                <span class="n">di</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_internal</span>      <span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">vibron_holder_</span><span class="o">.</span><span class="n">N</span><span class="p">))</span>
                
                <span class="n">Hc</span><span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">ci</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot; 0.5 * hb * {0} * ( exp( 1j * (({1} - {2}) * t + {3})) )&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rabi_label</span><span class="p">,</span>     <span class="n">trans_label</span><span class="p">,</span> <span class="n">laser_label</span><span class="p">,</span> <span class="n">phase_label</span><span class="p">),</span> <span class="p">[</span><span class="n">i_a</span><span class="p">]]</span>
                    <span class="p">,</span> <span class="p">[</span><span class="n">di</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot; 0.5 * hb * {0} * ( exp(-1j * (({1} - {2}) * t + {3})) )&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rabi_label</span><span class="p">,</span> <span class="n">trans_label</span><span class="p">,</span> <span class="n">laser_label</span><span class="p">,</span> <span class="n">phase_label</span><span class="p">),</span> <span class="p">[</span><span class="n">i_a</span><span class="p">]]</span>
                    <span class="p">]</span>

                <span class="c">#------------------- rotating wave approx ------------------- </span>
                <span class="n">rwa_c</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">])</span>
                        <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">])</span>
                        <span class="p">]</span>
                <span class="c">#------------------- add carrier terms ------------------- </span>
                <span class="k">if</span> <span class="n">col_args</span><span class="p">[</span><span class="n">rabi_label</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c">#then the term will be zero anyway</span>
                    <span class="k">continue</span>
                    
                <span class="n">rwa_takes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rwa_c</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Hc</span><span class="p">,</span> <span class="n">rwa_c</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                        <span class="n">H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                        <span class="n">rwa_takes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    
                
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">i_v</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">vibrons</span><span class="p">):</span>
                    <span class="n">eta_label</span> <span class="o">=</span> <span class="s">&quot;eta_A&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_a</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;V&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_v</span><span class="p">)</span>
                    <span class="n">vib_label</span> <span class="o">=</span> <span class="s">&quot;wz_V&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i_v</span><span class="p">)</span>
                    <span class="c">#------------------- set up the constants ------------------- </span>
                    <span class="n">col_args</span><span class="p">[</span><span class="n">eta_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">_eta</span><span class="p">[</span><span class="n">i_a</span><span class="p">][</span><span class="n">i_v</span><span class="p">]</span>
                    <span class="n">col_args</span><span class="p">[</span><span class="n">vib_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">freq</span>
                    <span class="n">d_osz</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">destroy</span>
                    
                    <span class="c">#------------------- set up the operators ------------------- </span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_internal</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="n">d_osz</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
                    <span class="n">cd</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_internal</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="n">d_osz</span><span class="p">)</span>
                    <span class="n">dc</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_internal</span>      <span class="p">,</span> <span class="n">d_osz</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>
                    <span class="n">dd</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">d_internal</span>      <span class="p">,</span> <span class="n">d_osz</span><span class="p">)</span>
                    
                    <span class="n">Hs</span><span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">cc</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot; 0.5 * hb * {0} * ( exp( 1j * (({1} - {2}) * t + {3})) ) * 1j * {4} * exp( 1j * {5} * t)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rabi_label</span><span class="p">,</span> <span class="n">trans_label</span><span class="p">,</span> <span class="n">laser_label</span><span class="p">,</span> <span class="n">phase_label</span><span class="p">,</span> <span class="n">eta_label</span><span class="p">,</span> <span class="n">vib_label</span><span class="p">),</span> <span class="p">[</span><span class="n">i_a</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="n">i_v</span><span class="p">]]</span>
                        <span class="p">,</span> <span class="p">[</span><span class="n">cd</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot; 0.5 * hb * {0} * ( exp( 1j * (({1} - {2}) * t + {3})) ) * 1j * {4} * exp(-1j * {5} * t)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rabi_label</span><span class="p">,</span> <span class="n">trans_label</span><span class="p">,</span> <span class="n">laser_label</span><span class="p">,</span> <span class="n">phase_label</span><span class="p">,</span> <span class="n">eta_label</span><span class="p">,</span> <span class="n">vib_label</span><span class="p">),</span> <span class="p">[</span><span class="n">i_a</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="n">i_v</span><span class="p">]]</span>
                        <span class="p">,</span> <span class="p">[</span><span class="n">dc</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot;-0.5 * hb * {0} * ( exp(-1j * (({1} - {2}) * t + {3})) ) * 1j * {4} * exp( 1j * {5} * t)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rabi_label</span><span class="p">,</span> <span class="n">trans_label</span><span class="p">,</span> <span class="n">laser_label</span><span class="p">,</span> <span class="n">phase_label</span><span class="p">,</span> <span class="n">eta_label</span><span class="p">,</span> <span class="n">vib_label</span><span class="p">),</span> <span class="p">[</span><span class="n">i_a</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="n">i_v</span><span class="p">]]</span>
                        <span class="p">,</span> <span class="p">[</span><span class="n">dd</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="s">&quot;-0.5 * hb * {0} * ( exp(-1j * (({1} - {2}) * t + {3})) ) * 1j * {4} * exp(-1j * {5} * t)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rabi_label</span><span class="p">,</span> <span class="n">trans_label</span><span class="p">,</span> <span class="n">laser_label</span><span class="p">,</span> <span class="n">phase_label</span><span class="p">,</span> <span class="n">eta_label</span><span class="p">,</span> <span class="n">vib_label</span><span class="p">),</span> <span class="p">[</span><span class="n">i_a</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="n">i_v</span><span class="p">]]</span>
                        <span class="p">]</span>
                    
                    <span class="c">#------------------- rotating wave approx ------------------- </span>
                    <span class="n">rwa_s</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">]</span> <span class="o">+</span> <span class="n">col_args</span><span class="p">[</span><span class="n">vib_label</span><span class="p">])</span>
                            <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">vib_label</span><span class="p">])</span>
                            <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">vib_label</span><span class="p">])</span>
                            <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col_args</span><span class="p">[</span><span class="n">trans_label</span><span class="p">]</span> <span class="o">-</span> <span class="n">col_args</span><span class="p">[</span><span class="n">laser_label</span><span class="p">]</span> <span class="o">+</span> <span class="n">col_args</span><span class="p">[</span><span class="n">vib_label</span><span class="p">])</span>
                            <span class="p">]</span>
                    <span class="c">#------------------- add sideband terms ------------------- </span>
                    <span class="k">if</span> <span class="n">col_args</span><span class="p">[</span><span class="n">eta_label</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                        
                    <span class="n">rwa_takes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rwa_s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">diff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">rwa_s</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                            <span class="n">H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                            <span class="n">rwa_takes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">GREEN</span><span class="p">(</span><span class="s">&quot;{1} of {2} terms survived the RWA (cutoff: {0})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="o">*</span><span class="n">rwa_takes</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">col_args</span>
</div>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<div class="viewcode-block" id="integrate_cf"><a class="viewcode-back" href="../../src.html#src.integration_routine.integrate_cf">[docs]</a><span class="k">def</span> <span class="nf">integrate_cf</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    this function implements the event integration for the `cf`. the event integration recalculates the hamiltonian everytime a laser is switched on or off. this avoids to recalculate parts of the hamiltonian, that are zero anyways during a certain time frame.</span>
<span class="sd">    </span>
<span class="sd">    :param cf: the canonical form of the integration problem</span>
<span class="sd">    :return: (times, exp) a list with the times and a list of lists for every observed property exp[#obs][#measure]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">res</span>
    <span class="n">GREEN</span><span class="p">(</span><span class="s">&quot;start integration&quot;</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    
    <span class="c">#------------------- reset holders ------------------- </span>
    <span class="n">atom_holder_</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">vibron_holder_</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="c">#------------------- checking kwargs ------------------- </span>
    <span class="n">at</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;atom&quot;</span><span class="p">]:</span>
        <span class="n">at</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    
    <span class="n">vb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;vibron&quot;</span><span class="p">]:</span>
        <span class="n">vb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vibron</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
    
    <span class="n">ls</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">events</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;laser&quot;</span><span class="p">]:</span>
        <span class="n">ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">laser</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">intervall</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">events</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intervall</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">events</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">intervall</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">events</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
        
    <span class="n">rabi</span> <span class="o">=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;rabi&quot;</span><span class="p">]</span> <span class="c">#matrix</span>
    <span class="n">eta</span> <span class="o">=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;eta&quot;</span><span class="p">]</span> <span class="c">#matrix</span>
    
    <span class="n">H</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">create_hamiltonian</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">ls</span><span class="p">,</span> <span class="n">rabi</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">cutoff</span> <span class="o">=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;cutoff&quot;</span><span class="p">],</span> <span class="n">hbar</span> <span class="o">=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;hbar&quot;</span><span class="p">])</span>
    
    <span class="c">#------------------- set up event structure ------------------- </span>
    <span class="n">act</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">col_event</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">i_h</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">act</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i_h</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">act</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i_h</span><span class="p">)</span>
        <span class="n">col_event</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">e</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">act</span><span class="p">)])</span>
    
    <span class="c">#col_event is a list with the following content:</span>
    <span class="c">#col_event[N][0]: event time</span>
    <span class="c">#col_event[N][1]: systems active (bc of laser pulses)</span>
    
    <span class="c">#------------------- assign tlist parts to col_res ------------------- </span>
    <span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">cf</span><span class="p">[</span><span class="s">&quot;lower&quot;</span><span class="p">],</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;upper&quot;</span><span class="p">],</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;measure&quot;</span><span class="p">])</span>
    <span class="n">space</span> <span class="o">=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;upper&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;lower&quot;</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i_e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_event</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;lower&quot;</span><span class="p">]:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i_e</span>
        <span class="k">if</span> <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;upper&quot;</span><span class="p">]:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">i_e</span>
    
    <span class="k">for</span> <span class="n">i_e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">e</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">space</span> <span class="o">*</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;measure&quot;</span><span class="p">]))]</span>
        
        <span class="k">if</span> <span class="n">i_e</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i_e</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">cf</span><span class="p">[</span><span class="s">&quot;lower&quot;</span><span class="p">],</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;upper&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">cf</span><span class="p">[</span><span class="s">&quot;lower&quot;</span><span class="p">],</span> <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">i_e</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cf</span><span class="p">[</span><span class="s">&quot;upper&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">col_event</span><span class="p">[</span><span class="n">i_e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        
    <span class="n">col_event</span> <span class="o">=</span> <span class="n">col_event</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="c">#------------------- create states/obs ------------------- </span>
    
    <span class="n">phi</span> <span class="o">=</span> <span class="n">create_phi</span><span class="p">()</span>
    
    <span class="n">obs</span><span class="p">,</span> <span class="n">laser_ops</span><span class="p">,</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">create_obs</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
    
    <span class="n">col_ops</span> <span class="o">=</span> <span class="n">create_collpase_ops</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
    
    <span class="n">opts</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">Odeoptions</span><span class="p">()</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">store_final_state</span> <span class="o">=</span> <span class="bp">True</span>
    
    <span class="c">#------------------- integration routine ------------------- </span>
    <span class="n">col_res</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#collected results</span>
    
    <span class="c">#=================== event integration ===================</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">col_event</span><span class="p">:</span>
        <span class="n">tlist_event</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">h_idx</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">H_event</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i_h</span> <span class="ow">in</span> <span class="n">h_idx</span><span class="p">:</span>
            <span class="n">H_event</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">H</span><span class="p">[</span><span class="n">i_h</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">H</span><span class="p">[</span><span class="n">i_h</span><span class="p">][</span><span class="mi">2</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">callback</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H_event</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">tlist_event</span><span class="p">,</span> <span class="n">col_ops</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">final_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">mesolve</span><span class="p">(</span><span class="n">H_event</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">tlist_event</span><span class="p">,</span> <span class="n">col_ops</span><span class="p">,</span> <span class="n">obs</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">final_state</span>
            <span class="n">col_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">GREEN</span><span class="p">(</span><span class="s">&quot;integration done in {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))))</span>
    
    <span class="c">#------------------- collect result helper ------------------- </span>
    <span class="n">collect_times</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">]</span>
    <span class="n">collect_expect</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="p">[[</span><span class="n">a</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expect</span><span class="p">))]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">collect_times</span><span class="p">(</span><span class="o">*</span><span class="n">col_res</span><span class="p">),</span> <span class="n">collect_expect</span><span class="p">(</span><span class="o">*</span><span class="n">col_res</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">laser_ops</span><span class="p">:</span>
        <span class="n">l_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">i_t</span> <span class="ow">in</span> <span class="n">zipi</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">):</span>
            <span class="n">l_res</span><span class="p">[</span><span class="n">i_t</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">t</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l_res</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">)):</span> <span class="c">#small fix</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">)]</span>
    
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Trapped Ion Sim  documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mario S. Koenz.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>